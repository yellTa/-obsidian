---
created: 2024-07-29 22:32
updated: 2024-07-29T23:55
tags:
  - algorithm
  - java
---
# while문 사용시 주의사항...

## 설명
```
while(true){
	언제나 종료조건을 잘 생각해야한다.
}
```

- 시간 초과가 나면 무한으로 돌고있다는 의미이다. 
### 예방법
while문에서 초기상태로 돌아왔나 확인해본다.(코테 문제를 풀다가 알게 됨)

## 출처/참고
내머리
[두 큐의 합 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/118667)

## 연결 문서
객체지향 프로그램은 데이터를 처리하는 메서드를 객체단위로 묶어서 설계하는 방식입니다. 객체는 데이터를 처리하는 메서드를 포함하고 있습니다. 이를 통해 데이터를 중심으로 프로그램을 작성하게 됩니다. 그렇게 되면 프로그램의 유지보수가 용이해지게 됩니다. 데이터를 조작하는 메서드를 수정한다던가 동일한 메서드가 다른 객체에서 다르게 동작할 수 있도록 하는 다형성을 이용해 재사용성과 유지보수성이 좋아지게됩니다. 저는 특히 개발할 때 상속을 중요히 여기는 편입니다. 상속은 큰 틀을 짜고 객체에 맞춰서 기능을 추가하거나 수정할 수 있기 때문입니다. 그러한 속성을 이용해서 Spring에서 기능이 새로 추가되거나 변경되었을 때 새로운 인터페이스를 만들고 메소드를 상속받아 새로운 버전을 만들어 수정했습니다. 그 결과 과거의 로직을 남겨 정확히 어떤 부분이 수정되고 개선되었는지 확인할 수 있었습니다.



인터페이스는 클래스가 구현해야할 메서드를 정의해놓은 그룹입니다. 특히 자바에는 다중상속이 가능하여 여러가지의 인터페이스를 상속받아 사용할 수 있습니다. 저 또한 Spring의 모든 기능을 인터페이스로 작성하고 해당 인터페이스를 상속받는 형식으로 구성했습니다. 그리고 Config파일에서 bean을 한꺼번에 관리할 수 있도록 설정했습니다. 인터페이스를 상속받아 객체를 구성했기 때문에 객체지향 프로그래밍의 다형성을 지키며 개발할 수 있었습니다. 또한 코드 유지보수를 수행하게 되면서 매번 기존에 있던 메소드를 복사해서 붙여넣지 않고 오버라이드해서 구현할 수 있어 프로그램이 갖고 있던 로직을 일관성있게 유지할 수 있었습니다.


둘 다 자바에서 메서드를 재정의하는 기법입니다. 오버로딩은 같은 이름의 메서드를 재정의 하는 것입니다. 매개변수를 다르게 한다던가, 타입이 달라야하는 식으로 같은 이름의 메서드를 재정의합니다. 예를 들어 똑같은 덧셈로직을 구현한다고 가정했을 때 long타입 int타입의 메서드를 같은 이름의 메소드로 생성할 수 있습니다. 반면 오버라이딩은 자식 클래스가 부모의 메서드를 재정의하는 것입니다. 이때 메서드의 이름, 매개변수가 변경되면 안됩니다. 오버라이딩은 부모 클래스를 상속받아 서로 다른 객체에서 메서드를 구현할 때 그리고 오버로드는 자주 사용하지만 매개변수가 다른 메서드를 정의할 때 사용합니다. 


배열은 메모리에 일렬로 저장됩니다. 그에 반해 arrayList는 일렬로 저장되지 않고 메모리에 연결된 노드의 정보까지 함께 저장합니다. 따라서 메모리 사용량이 배열보다 높습니다. 또한 배열은 크기를 지정해줘야 하는 반면 ArrayList는 크기를 지정해주지 않고 동적으로 조정할 수 있습니다. 이런 특성 때문에 배열을 사용할 시에는 배열의 크기를 파악하고 사용해야 합니다. 그렇지 않으면 메모리가 낭비될 수 있기 때문입니다. ArrayList는 크기를 파악할 수 없는 데이터를 넣을 때 용이합니다. 

RESTful API에서 REST는 HTTP 프로토콜을 이용하여 서버 클라이언트간 통신하는 것을 의미합니다. http 프로토콜을 사용하기 때문에 범용성이 좋습니다.하지만 HTTP프로토콜을 사용하기 때문에 쓸 수 있는 메서드가 한정적인라는 단점 또한 가지고 있습니다. 저 또한 프로젝트를 수행하면서 Front단과 REST API로 통신을 수행했습니다. 전달되는 API는 JSON으로 표현했습니다. API를 통해서 서로 다른 언어를 씀에도 불구하고 일관된 데이터를 주고 받을 수 있었습니다. 

JPA와 MyBatis의 가장 큰 차이점은 SQL작성이라고 생각합니다. MyBatis는 SQL문을 직접 작성합니다. 이는 개발자가 SQL 문법을 정확하게 알고 있어야 합니다. 하지만 Spring JPA는 ORM기술로 데이터 베이스 테이블을 자바 객체로 매핑합니다. 또한 JPA는 메소드로 쿼리를 작성할 수 있는 쿼리메소드를 지원하고 트랜잭션도 함께 제공합니다. 이를 통해 개발자가 개발에 좀 더 집중할 수 있는 환경을 만들어줍니다. 저 역시도 JPA를 이용하여 데이터베이스에 수정작업을 수행했습니다. 간단하게 메소드를 통해서 CRUD작업을 수행했으며 물론 쿼리가 필요한 곳에는 직접 쿼리를 작성해서 사용하기도 했습니다. 테이블과 연결되는 객체를 구성하면서 데이터베이스를 열지 않아도 프로젝트 테이블 구성을 확인할 수 있어 좋았고 무엇보다 SQL에 집중해야할 시간을 개발에 집중할 수 있었습니다. 


싱글톤 패턴과 MVC패턴을 설명드리겠습니다. 싱글톤 패턴은 특정 클래스의 인스턴스를 오직 하나만 생성하고 이에 대한 전역 접근을 사용하는 디자인입니다. Spring Bean또한 싱글톤패턴을 사용하고 있습니다. 싱글톤 패턴은 매번 객체를 새로 생성하지 않아도 되지만 반대로 전역변수, 전역함수를 사용할 땐 조심해야합니다. 다른 객체들이 접근해서 값을 변경하면 일관성을 해치기 때문입니다. 저 또한 Spring프로젝트 진행시 스프링 빈으로 등록된 객체는 전역변수의 사용을 최소한으로 줄이는 방향으로 구성하고 있습니다.
또 다른 패턴은 MVC패턴입니다. 애플리케이션을 Model, View, Controller로 나눠서 분리합니다. Model은 애플리케이션 비지니스로직, View는 화면에 나타나는 시각적인 부분, Controller는 사용자 입력을 처리하고 모델,뷰로 전달합니다. 저 또한 Spring프로젝트를 MVC패턴으로 구성해 유지보수가 용이하도록 설계했습니다.

Di는 의존성을 외부에서 주입하는 방식입니다. DI를 통해서 스프링은 빈을 주입받고 빈을 싱글톤으로 관리하여 요청시 마다 객체를 매번 생성하는 것이 아니라 싱글톤으로 관리하게 됩니다.


CI/CD는 지속적 통합과 지속적 배포의 약자입니다. CI/CD를 통해서 개발, 배포 프로세스를 자동화할 수 있습니다. 저 또한 AWS 코드 디플로이를 이용해서 CI/CD를 구성한 경험이 있습니다. github의 main브랜치에 수정사항이 합쳐지면 github Action을 통해서 코드를 자동으로 빌드후 EC2 인스턴스로 옮겨 애플리케이션을 수행하고 로그파일을 생성했습니다. 그 결과 개발을 수행하면서 수정사항을 main에 합치게 되면 기존에는 직접 빌드 후 서버에 올리던 복잡한 과정을 줄일 수 있게 되었습니다. 또한 github Action에 작성한 스크립트를 기반으로 로그파일을 날짜+시간으로 자동 생성하여 일관성 있게 관리할 수 있게 되었습니다. 이 경험으로 CI/CD는 유지보수, 개발 편의성을 위해서 필수라는 생각이 들었습니다.

생성자 주입을 권고하는 이유는 불변성을 보장해주기 때문입니다. 생성자 주입을 사용하면 객체가 생성될 때 필요한 모든 의존성을 주입받아야합니다. 객체가 생성된 이후에는 의존성을 변경할 수 없도록 하여 객체의 불변성을 유지합니다. 또한 객체가 필요로하는 의존성을 명확하게 선언할 수 있고 한눈에 파악할 수 있도록 하지만 주입 받아야하는 의존성이 많아지면 매개변수 목록이 길어져 코드가 복잡해질 수 있었습니다. 저는 프로젝트에 모든 빈을 확인하고 싶었습니다. 또한 주입받아야하는 의존성도 많았기 때문에 현재 webConfiguration에서 한꺼번에 관리하고 있습니다. 하지만 생성자 주입 방식을 권고하는 만큼 복잡한 빈 등록은 config파일 수행하고 일반적인 서비스 ,리포지토리, 컨트롤러는 생성자 주입 방식을 사용하기위한 리팩토링 진행중입니다.