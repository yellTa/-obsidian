---
created: "{{date}} {{time}}"
updated: 2024-08-27T10:26
tags:
  - TIL
출처: 
---
# 오늘의 코테 문제
[도미노](https://www.acmicpc.net/problem/1552)

오늘의 코테 문제는 도미노? 이다. 
문제 자체의 해석은 어렵지 않았다.

``` java
    private static void dfs(int k) {  
        if (k == m) {  
            //사이클을 판별  
            int sum=0;  
            for(int i=0; i<m; i++){  
                sum *= arr[i].value;  
                System.out.print(arr[i].x + " : "+arr[i].y+ "  | ");  
            }            System.out.println();  
  
            findCycle();  
  
            return;  
        }  
        int ist = 1;  
        int tst = 1;  
        //그 다음 선택지를 사용  
        if (k != 0) {  
            Pos cur = arr[k - 1];  
            ist = cur.x;  
            tst = cur.y;  
        }        for (int i = ist; i <= m; i++) {  
            for (int t = tst; t <= m; t++) {  
                if (col[i] < 2) {//행 2회 이만  
                    if (row[t] < 2 && isused[i][t] == 0) {// 열 2 회선택 미만인 경우에만  
                        //map의 위저 정보 값 넣어주기  
                        //뽑은 값은 배제를 위해서 배제하는 배열 만들기  
                        col[i] = col[i] + 1;  
                        row[t] = row[t] + 1;  
                        isused[i][t] = 1;  
  
                        arr[k] = new Pos(i, t, map[i][t]);  
                        dfs(k + 1);//하고 들어가서 또 탐색  
  
                        col[i] = col[i] - 1;  
                        row[t] = row[t] - 1;  
                        isused[i][t] = 0;  
  
                    }                }            }        }    }  
  
```
개인적으로는 완전탐색에서 내가 원하고싶은 데이터만 뽑는게 조금 재미있었다(?) N과 M문제를 풀면서 알게된 조합을 기본 틀로 사용했고 2차원 배열의 데이터를 정렬해서 뽑는건 이번이 처음이었기 때문


## 재귀함수를 이용한 탐색의 특징
### 끝나는 지점이 명확함

```java
if (k == m) {  
            //사이클을 판별  
            int sum=0;  
            for(int i=0; i<m; i++){  
                sum *= arr[i].value;  
                System.out.print(arr[i].x + " : "+arr[i].y+ "  | ");  
            }            System.out.println();  
  
            findCycle();  
  
            return;  
        }  
```

여기서 k는 depth이고 m은 깊이? 내가 도달하고싶은 깊이이다.  `k==m`이 되는 순간 코드는 종료된다. 

### 재귀 함수를 돌리기 위해 필요한 준비물
```java
static int m; //노드의 수  
  
static int[][] map;   //map의 정보 탐색하려는 것의 정보
//자기자신 제외 중복  
static int[][] isused;   //썻는지 안썼는지 표시할 것

// 문제에서 같은 행에서 2개 초과로 뽑아쓰면 안된다고 했으니까 그걸 확인해줄 애들
static int[] col; 
//마찬가지로 같은 열에서 2개 초과로 뽑아쓰면 안된다고 헀으니까 그걸 확인할 애들
static int[] row;  
  
  
//위치값을 저장할 배열  
static Pos[] arr;
```

이렇게 전역변수에 지정해놓고 

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
int tc = Integer.parseInt(br.readLine());//depth가 된다.  
m = tc;  
col = new int[tc+10];  
row = new int[tc+10];  
map = new int[tc + 10][tc + 10]; // 0,0라인 배제를 위해서  
isused = new int[tc + 10][tc + 10];  
arr = new Pos[m];  
mVis = new int[m+1];
```

재귀가 시작되기 전에 값을 초기화 해준다. 

### 문제에서 바라는 조건에 맞춰 코드 짜기
```java
		//시작점 위치 조절
		// for문의 시작점 위치 조절은 순열의 중복을 제거한다.
		// ex) 1,1  | 2,1   -> 2,1 | 1,1  -> 둘은 같다고 판단해서 이걸 제거해주는 역할
		//depth가 0일때는 ist는 초기값으로 들어간다.
		int ist = 1;  
        int tst = 1;  
        //depth가 0이 아니게 될때에는 arr배열에 k-1(그 전 depth에서 저장한 값)을 넣어준다. 
        if (k != 0) { 
		        //그 전에 선택했던 것 이후부터 수행해야 하기 때문이다. 
            Pos cur = arr[k - 1];  
            ist = cur.x;  
            tst = cur.y;  
            //시작점을 ist,tst로 지정 이러면 순열의 중복을 제거할 수 있다. 
        }        for (int i = ist; i <= m; i++) {  
            for (int t = tst; t <= m; t++) {  
            //어떤 행을 선택하는데 그 행에서 사용한 값이 2회 미만인 경우
                if (col[i] < 2) {//행 2회 미만
                //어떤 열을 선택하는데 그 열에서 사용한 값이 2회 미만인 경우
                    if (row[t] < 2 && isused[i][t] == 0) {// 열 2 회선택 미만인 경우에만  
                        //map의 위저 정보 값 넣어주기  
                        //뽑은 값은 배제를 위해서 배제하는 배열 만들기  
                    //해당 열과 행에서 원소를 뽑았으니까 값에 표시해주기
                    //해당col[idx]값이 2 이상이된다면 
                        col[i] = col[i] + 1;  
                        row[t] = row[t] + 1;  
                        //좌표값을 사용했으니까 isused에 표시해주기
                    
                        isused[i][t] = 1;  
						  
                        arr[k] = new Pos(i, t, map[i][t]);  
                        dfs(k + 1);//하고 들어가서 또 탐색  
  
                        col[i] = col[i] - 1;  
                        row[t] = row[t] - 1;  
                        isused[i][t] = 0;  
  
                    }                }            }        }    }  
```
Pos는 x,y의 정보를 담고있다. 배열로넣기 싫어서 저렇게 넣었다. 아무튼


<span style="color:rgb(255, 128, 128)">재귀의 시작점은 순열의 중복을 제거</span>해준다




## 끝나는 기준


언제나 재귀함수를 이용한 탐색의 특징이 있는데

## 부제목
배운것에 대해서 간략하게 작성할 것


---
# REVIEW
---
 #99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL