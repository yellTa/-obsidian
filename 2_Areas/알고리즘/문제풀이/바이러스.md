---
created: 2024-09-07 12:50
updated: 2024-09-07T12:59
tags:
  - algorithm
  - graph
  - bfs
  - dfs
출처: 
---
# 바이러스
[바이러스](https://www.acmicpc.net/problem/2606)

백준 바이러스 문제이다.

## 인접리스트와 Queue를 활용한 BFS풀이
```java
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.sql.SQLOutput;  
import java.util.*;  
  
class Main {  
    static int [] vis;  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
  
        int N = Integer.parseInt(br.readLine());  
  
        int V = Integer.parseInt(br.readLine());  
        vis= new int[N+1];  
  
        StringTokenizer st;  
        //인접 리스트 활용 예정  
  
        ArrayList<ArrayList<Integer>> list = new ArrayList<>();  
  
        for(int i=0;i  < N+1; i++){//0부터 N번까지  
            ArrayList<Integer> arr = new ArrayList<>();  
            list.add(arr);  
        }  
  
  
        for(int i=0; i<V; i++){  
            st = new StringTokenizer(br.readLine());  
  
            int x = Integer.parseInt(st.nextToken());  
            int y = Integer.parseInt(st.nextToken());  
  
            list.get(x).add(y);  
            list.get(y).add(x);  
        }  
  
        find(1, list);  
  
        int answer=0;  
        for(int x : vis){  
            if(x==1){  
                answer++;  
            }  
        }  
        System.out.println(--answer);  
    }  
  
    private static void find(int start, ArrayList<ArrayList<Integer>> list){  
        Queue<Integer> q = new LinkedList<>();  
  
        q.add(start);  
        vis[start] =1;  
  
        while(!q.isEmpty()){  
            int cur = q.poll();  
            for(int x : list.get(cur)){  
                if(vis[x]==0){  
                    q.add(x);  
                    vis[x]=1;  
                }  
            }  
        }  
    }  
  
}
```
노드에 연결된 값을 Queue를 통한 BFS를 통해 탐색했다. 
이때 인접 리스트를 활용해서 순회를 돌도록 설정했다.

## 인접행렬과 재귀를 활용한 dfs문제 풀이
```java

import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.sql.SQLOutput;  
import java.util.*;  
  
class Main {  
    static int [] vis;  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
  
        int N = Integer.parseInt(br.readLine());  
  
        int V = Integer.parseInt(br.readLine());  
        vis= new int[N+1];  
  
  
        //인접 행렬  
        int[][] arr = new int[N+1][N+1];  
  
        StringTokenizer st;  
        //인접 리스트 활용 예정  
  
        for(int i=0; i<V; i++){  
            st = new StringTokenizer(br.readLine());  
  
            int x = Integer.parseInt(st.nextToken());  
            int y = Integer.parseInt(st.nextToken());  
  
            //무방향 인접 행렬 생성  
            arr[x][y]=1;  
            arr[y][x]=1;  
        }  
  
        find(1, arr);  
  
        int answer=0;  
  
        for(int x : vis){  
            if(x==1){  
                answer++;  
            }  
        }  
        System.out.println(--answer);  
    }  
  
    private static void find(int start, int[][] arr){  
      vis[start]=1;  
  
      for(int i=0; i<arr.length;i++){  
          if(arr[start][i]==1 && vis[i]==0){//start번의 행과 연결된 노드가 있고 해당 노드가 검사를 안한 친구라면?  
              find(i,arr);  
          }  
      }  
    }  
  
}
```


## 두 코드의 차이점
### 인접리스트를 활용한 BFS코드
``` java
private static void find(int start, ArrayList<ArrayList<Integer>> list){  
        Queue<Integer> q = new LinkedList<>();  
  
        q.add(start);  
        vis[start] =1;  
  
        while(!q.isEmpty()){  
            int cur = q.poll();  
            for(int x : list.get(cur)){  
                if(vis[x]==0){  
                    q.add(x);  
                    vis[x]=1;  
                }  
            }  
        }  
```

Queue에 인접한 노드들을 넣어주는 방식이다. Queue에 노드를 넣는 순간 vis에 해당 노드는 검사를 수행한 노드라고 표시한다. 예를 들어서

# 결론

# REVIEW


---
# 참고

# 연결문서