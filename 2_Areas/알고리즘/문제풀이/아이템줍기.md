---
created: 2024-08-22T17:33
updated: 2024-08-22T18:36
---

[아이템 줍기](https://school.programmers.co.kr/learn/courses/30/lessons/87694)
단순한 BFS문제라고 생각했으나 아니었음 ㅋ

우선 문제를 해결하기 위해 나는
그래프를 컴퓨터가 알아볼 수 있는 형식으로 그려야한다고 생각했다.


```java
import java.util.*;

class Solution {
    static int[][] board;
    static int[] dx = {1, -1, 0, 0}; // 상하좌우
    static int[] dy = {0, 0, 1, -1}; // 상하좌우
    static boolean[][] visited;
    
    public int solution(int[][] rectangle, int characterX, int characterY, int itemX, int itemY) {
        // board 크기는 101x101로 충분히 크게 설정
        board = new int[55][55];
        visited = new boolean[55][55];
        
        // 2배 확대하여 좌표를 더 정확하게 관리
        for (int[] rec : rectangle) {
            int x1 = rec[0];
            int y1 = rec[1];
            int x2 = rec[2];
            int y2 = rec[3];
           //x축 채우기
            
            //위의 방법을 사용하면 말 그대로 사각형의 안쪽만 비어있게 된다.
            //둘이 겹쳐지게 된다면 이 방법은 사용할 수 없음
            //1로채우기
//             for(int x = x1; x<=x2; x++){
//                 for(int y =y1; y<y2; y++){
//                     board[x][y] =1;
//                 }
//             }         
            
//             //0으로 테두리만 남기기
//             for(int x = x1+1; x<x2; x++){
//                 for(int y =y1+1; y<y2-1; y++){
//                     board[x][y] =0;
//                 }
            
            
            //테두리만 입력하는 방법
            //x기준 먼저 채우기
                for(int x = x1; x<=x2; x++){
                    board[x][y1] = 1;
                    board[x][y2]=1;
                }
            //y기준 테두리 표시하기
                for (int y = y1; y <= y2; y++) {
                    board[x1][y] = 1; // 좌측 경계
                    board[x2][y] = 1; // 우측 경계
                }

            
            }
             for(int i=0; i<13; i++){
            for(int k=0; k<13; k++){
                System.out.print(board[i][k]+ " ");
            }
            System.out.println();
        }
        
       
        return 0;
    }

}

```

## 첫 시도
처음에는 범위내에 있는 모든 값을 1로 채우고 안에 있는 것을 0으로 바꿔주는 방식으로 선택했다.

![[Pasted image 20240822173749.png]]
박스가 하나인 경우는 내가 원하는대로 잘 나오는 것을 확인할 수 있었다

![[Pasted image 20240822173810.png]]
하지만 여러개일땐 달랐다 엉어엉엉엉

## 두 번째 시도  테두리만 그려보기

```java
import java.util.*;

class Solution {
    static int[][] board;
    static int[] dx = {1, -1, 0, 0}; // 상하좌우
    static int[] dy = {0, 0, 1, -1}; // 상하좌우
    static boolean[][] visited;
    
    public int solution(int[][] rectangle, int characterX, int characterY, int itemX, int itemY) {
        // board 크기는 101x101로 충분히 크게 설정
        board = new int[55][55];
        visited = new boolean[55][55];
        
        // 2배 확대하여 좌표를 더 정확하게 관리
        for (int[] rec : rectangle) {
            int x1 = rec[0];
            int y1 = rec[1];
            int x2 = rec[2];
            int y2 = rec[3];
           //x축 채우기

//             //테두리만 입력하는 방법
            //x기준 먼저 채우기
                for(int x = x1; x<=x2; x++){
                    board[x][y1] = 1;
                    board[x][y2]=1;
                }
            //y기준 테두리 표시하기
                for (int y = y1; y <= y2; y++) {
                    board[x1][y] = 1; // 좌측 경계
                    board[x2][y] = 1; // 우측 경계
                }

            }
            for(int i=0; i<13; i++){
                for(int k=0; k<13; k++){
                    System.out.print(board[i][k]+ " ");
            }
            System.out.println();
        }
        
       
        return 0;
    }

}

```


![[Pasted image 20240822174709.png]]
이제 테두리가 겹치는부분을 0으로 메꿔야한다...


## 위 방식들의 문제점
사실 위 방식들이 모두 추구하는 것은 똑같다.

### 내가 원하는 도표로 그리는 것
하지만 한 가지 문제점이 있는데 

![[Pasted image 20240822180424.png]]

이렇게 표현할 수 없는 경우이다. 

좀 더 자세하게 표현하자면 
![[Pasted image 20240822181037.png]]

## 내가 원하는 그래프 모양으로 만드려면 어떻게 해야할까?
저런식으로 표현되면 우리가 원하는 답을 잘 얻을 수 없다. 그럼 어떻게 표현해야 할까?


![[Pasted image 20240822182843.png]]
왼쪽은 원래 원하는 경로이고 오른쪽은 아니다!!!

## 해결안1. 그래프를 키워보기
![[Pasted image 20240822183537.png]]
왼쪽의 그래프를 2배로 변경하면 오른쪽처럼 된다.
그러면 ㄷ자 커브도 처리할 수 있게 된다!

