---
created: 2024-08-16T13:21
updated: 2024-08-16T13:55
---

https://www.acmicpc.net/problem/1406

# 처음 시도한 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

public class Main {


    public static void main(String args[]) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = br.readLine();

        List<Character> list = new ArrayList<>();
        for(int i=0; i<s.length(); i++){
            list.add(s.charAt(i));
        }


        int tc = Integer.parseInt(br.readLine());

        int idx=list.size();

        while(tc-- != 0 ){
            StringTokenizer st = new StringTokenizer(br.readLine());
            String command = st.nextToken();

            if(command.equals("L")){
                if(idx!=0)idx--;

            }else if(command.equals("D")){
                if(idx !=list.size())idx++;

            }else if(command.equals("B")){
                if(idx!=0){
                    idx--;
                    list.remove(idx);
                }
            }else if(command.equals("P")){
                char word = st.nextToken().charAt(0);
                list.add(idx, word);
                idx++;
            }

        }
        String answer="";
        for(char c : list){
            answer += Character.toString(c);
        }

        System.out.println(answer);
    }
}

```
ArrayList를 사용한 풀이이다.

여기서 문제가 발생하게 되는데  ArrayList는 삽입과 삭제가 일어날 때 O(N)번의 연산을 수행하게 된다. 

해당 문제에서는 삽입과 삭제 자료구조를 돌아다니는 조회가 빈번하게 일어난다. 이를 빠르게 해결할 방법을 찾아야한다. 

# LinkedList의 iterator를 이용하자
에전에 c++로 문제를 풀었을 떄 사용한 방법이다. iter를 구현해서 iter이 가르키는 값을 이용해 값을 가공?하는 방법이다.





# 참고
https://minhamina.tistory.com/17


# 연결문서
[[ArrayList와 LinkedList]]