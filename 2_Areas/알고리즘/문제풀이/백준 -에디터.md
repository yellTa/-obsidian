---
created: 2024-08-16T13:21
updated: 2024-08-16T14:08
---

https://www.acmicpc.net/problem/1406

# 처음 시도한 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

public class Main {


    public static void main(String args[]) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = br.readLine();

        List<Character> list = new ArrayList<>();
        for(int i=0; i<s.length(); i++){
            list.add(s.charAt(i));
        }


        int tc = Integer.parseInt(br.readLine());

        int idx=list.size();

        while(tc-- != 0 ){
            StringTokenizer st = new StringTokenizer(br.readLine());
            String command = st.nextToken();

            if(command.equals("L")){
                if(idx!=0)idx--;

            }else if(command.equals("D")){
                if(idx !=list.size())idx++;

            }else if(command.equals("B")){
                if(idx!=0){
                    idx--;
                    list.remove(idx);
                }
            }else if(command.equals("P")){
                char word = st.nextToken().charAt(0);
                list.add(idx, word);
                idx++;
            }

        }
        String answer="";
        for(char c : list){
            answer += Character.toString(c);
        }

        System.out.println(answer);
    }
}

```
ArrayList를 사용한 풀이이다.

여기서 문제가 발생하게 되는데  ArrayList는 삽입과 삭제가 일어날 때 O(N)번의 연산을 수행하게 된다. 

해당 문제에서는 삽입과 삭제 자료구조를 돌아다니는 조회가 빈번하게 일어난다. 이를 빠르게 해결할 방법을 찾아야한다. 

# LinkedList의 iterator를 이용하자
에전에 c++로 문제를 풀었을 떄 사용한 방법이다. iter를 구현해서 iter이 가르키는 값을 이용해 값을 가공?하는 방법이다.

```java
package math.순열;  
  
import java.io.*;  
import java.util.*;  
  
public class Practice {  
  
  
    public static void main(String args[]) throws IOException {  
  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
  
        String s = br.readLine();  
  
        LinkedList<Character> list = new LinkedList<Character>();  
        for(int i=0; i<s.length(); i++){  
            list.add(s.charAt(i));  
        }  
  
  
        int tc = Integer.parseInt(br.readLine());  
  
        ListIterator<Character> iter = list.listIterator();  
  
        while(iter.hasNext()){// iterator를 이용해서 마지막 커서 위치로 이동시킨다.  
            iter.next();  
        }  
  
        while(tc-- != 0 ){  
            StringTokenizer st = new StringTokenizer(br.readLine());  
            String command = st.nextToken();  
  
            if(command.equals("L")){  
                if(iter.hasPrevious()) iter.previous(); //왼쪽으로 이동  
  
            }else if(command.equals("D")){  
                if(iter.hasNext()) iter.next();//오른쪽으로 이동  
  
            }else if(command.equals("B")){  
                if(iter.hasPrevious()){  
                    iter.previous(); //왼쪽으로 이동  
                    iter.remove(); //remove는 previous나 next로 반환된 가장 마지막 요소를 제거한다.  
                    //즉 remove하기 전에 iter을 움직여줘고 바로 삭제해야 원하는 값을 지운다는 뜻  
                }  
            }else if(command.equals("P")){  
                char word = st.nextToken().charAt(0);  
                iter.add(word);  
            }  
  
        }  
  
        for(char c : list){  
            bw.write(Character.toString(c)) ;  
        }  
  
        bw.flush();;  
        bw.close();  
    }  
}

```

# Stack을 이용한 풀이
애초에 List가 아니라 Stack을 이용해서도 가능하다.
Stack은 삽입, 삭제가 O(1)으로 이루어진다. 왼쪽 오른쪽을 나눠서 Stack에 저장하면 된다. 



# 참고
https://minhamina.tistory.com/17


# 연결문서
[[ArrayList와 LinkedList]]