---
created: 2024-09-05T21:23
updated: 2024-09-05T21:42
tags:
  - algorithm
  - graph
---
# 인접 행렬
그래프의 관계를 이차원 배열로 나타내는 방식
## 방향이 있는 인접행렬

![[Pasted image 20240905212942.png]]

방향이 있는 경우의 그래프의 모습이다. 
1번에서 2,3,4 번으로 뻗어나가고 있으니 
1번 행이 0,1,1,1 로 표현된다.

그리고 4번 노드는 3번으로만 뻗어나가기 때문에 
0,0,1,0으로 표현된다.

여기서는 1로 표현했지만 각 간선의 가중치를 표현할 수도 있다.

예를 들어 1번에서 2번으로 향하는데 6만큼의 비용이 든다고 가정하자 
![[Pasted image 20240905213149.png]]

그럼 이런 모습의 인접행렬이 나오게 된다.

해석은 1번에서 2번으로 향하는데 드는 비용이 6 
따라서 <span style="color:rgb(255, 128, 128)">1번행, 2번열의 값이 1번에서 2번으로 향하는데 드는 비용</span>이다. 


## 방향이 없는 인접 행렬
![[Pasted image 20240905213424.png]]
방향이 없는 인접행렬의 특징은 바로 대칭이다.
자기 자신(1,1이나 2,2 혹은 3,3 이런 애들)을 기준으로 대칭을 이루고 있는 형태이다. 
삽각형으로 접었을 때 마주보는 값이 일치한다고? 생각하면 된다. 


## 장점
1. 구현이 쉽다.
   <span style="color:rgb(255, 128, 128)">노드i 노드 k의 연결 상태를 `인접행렬[i][k]`의 형태로 O(1)</span>에 알아낼 수 있다.

## 단점
1. 노드와 연결된 갯수 확인에서 시간이 오래걸릴 수 있다.

이 말은 무엇이냐면 

만약 저 그림에서 노드의 갯수는 1,2,3,4 총 4개이다.
1번 노드와 연결된 노드 값을 알아내려면 1번 행을 탐색해야한다. 

![[Pasted image 20240905213903.png]]

이 그림에서는 1번 노드와 연결된 것이 2,3,4 세 개인 것을 알 수 있다.
우리는 그림으로 보아서 직관적으로 3개임을 알 수 있지만 컴퓨터같은 경우에는 그래프를 읽어야만 알 수 있다.

즉 노드의 갯수가 10개면 
1번 행에서 10개의 열을 모두 확인해야한다는 것이다. 
그렇다면 노드의 수가 많고 간선의 수가 적을 때 문제가 발생한다.

노드의 수가1000개일때 간선의 수는 2개라고 하자

안타깝게도 인접 행렬에서는 행에 있는 열의 정보를 모두 읽어와야하기 때문에 1000개의 연산이 수행된다. 단 2개의 간선 존재 여부를 위해 비효율적으로 일해야하는 것이다. 


# 인접리스트
그래프의 연결 관계를 list로 나타내는 것
이때 C++에서는 vector로 표현하고 자바에서는 주로 ArrayList를 사용한다. 










---
# Reference
https://sarah950716.tistory.com/12