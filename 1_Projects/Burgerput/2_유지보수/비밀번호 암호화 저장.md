---
Created time: Invalid date
Last edited time: Invalid date
Posted to Naver: false
업로드할까?: false
---
# OBJECT/SUBJECT:

front-end단에서 평문으로 받은 암호를 서버에 암호화해서 저장하기!

  

# ANALYSIS:

프론트 엔드 단에서 암호화를 수행하면 추가적인 보안을 제공할 수 있지만, 구현의 복잡성과 키 관리의 어려움을 동반한다.

  

# HOW TO:

1. front-end단에서 api를 통해 id, password를 보낸다.
2. Spring Security의 BCrypt해시 알고리즘을 사용한다. → gradle에 의존성 추가 필요
3. 비밀번호 해시 및 저장 로직을 작성한다.

  

> [!important]  
> build.gradle  

```Java
//Spring Security 의존성 추가
    implementation 'org.springframework.boot:spring-boot-starter-security'
```

  

  

> [!important]  
> MasterAccount(Domain)  

```Java
@Data
@Entity
public class MasterAccount {

    @Id
    @JsonIgnore
    @Column(name="master_id")
    private String masterId;

    @Column(name="master_pw")
    private  String master_pw;

}
```

  

  

> [!important]  
> Config  

```Java

    //Spring Security BCypt 설정을 위한 bean주입
    @Bean
    public PasswordEncoder passwordEncoder() {return new BCryptPasswordEncoder();
    
//Save Data에 masterAccount계정을 저장하는 로직이 담겨있다. 따라서 SaveData에 
//필요한 의존성을 추가해준다. - MasterAccountRepository, PasswordEncoder
//패스워드 인코더를 사용해서 비밀번호르 암호화 할 예정      
    
    @Bean
    SaveData saveData(
            MachineRepository machineRepository,
            FoodRepository foodRepository,
            CustomFoodRepository customFoodRepository,
            CustomMachineRepository customMachineRepository,
            MasterAccountRepository masterAccountRepository,
            PasswordEncoder passwordEncoder) {
        return new SaveDataV1(
                machineRepository,
                foodRepository,
                customFoodRepository,
                customMachineRepository,
                masterAccountRepository,
                passwordEncoder);
    }
```

Spring Bean을 추가해준다.

  

# CONCLUSION:

## 원인

  

## 결과

  

  

## 부제목

> [!important]  
> code file name  

```Shell
# codes
```

  

### 결론

> _**아 이렇게 이렇게 이렇게 하면 되는 구나**_

# SOLVE:

  

# REVIEW: