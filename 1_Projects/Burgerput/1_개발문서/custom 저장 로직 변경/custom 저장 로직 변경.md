---
Created time: Invalid date
Last edited time: Invalid date
Progress: end
on Naver: false
업로드할까?: false
---
# JPA 이름 이슈…

![[Untitled.png]]

JPA에서 findById, findOne, findAll() 은 모두 @id로 지정된 변수 이름으로 DB에서 값을 찾는다. 우리가 실제로 검색에 사용하는 컬럼명은 id인데 num으로 검색하니 여간 이런저런 JPA기능을 제대로 사용할 수 없게 되었다…

  

일단 DB컬럼과 변수명을 바꾸지 않는 방법으로 개발을 시도해봤다.

  

---

## Custom테이블의 저장 로직의 문제점

지금까지 custom table은 모두 truncate를 거친 후 새로운 객체를 생성해 저장했었다. 이를 변경할 예정이다.

  

1. 커스텀 테이블은 zenput의 순서와 동일하게 저장되어야 한다.
    - 따라서 num(pk)를 사용하고 있다.
2. 커스텀 테이블의 num는 임의로 값을 조정할 수 없다.
    - 중복이 될 수도 없고 임의로 값을 조정할 수도 없다.  
        예시로 1 ,2 ,3 ,4 정보가 있다고 하고 1, 2, 3,4(새로운 정보),5 순서로 데이터가 저장된다고 하자.  
          
        현재 로직으로는 1,2,3,4 정보를 모두 지우고 1,2,3,4,5 이런 순서로 저장한다. customTable에서 사용자가 지정한 min, max값도 모두 지우는 것이다. 사용자가 지정한 값을 변경하지 않으려면 1,2,3,4 의 정보는 그대로 두고 3,4 사이에 새로운 값을 넣어야한다.  
          
        현재 num은 pk 중복될 수 없고 DB에 값을 자동으로 위임한다.(자동증가 로직을 넣어둠)  
        즉 데이터를 중간에 넣으려고 할 때는 에러가 발생한다는 의미이다.  
        

  

사용자의 임의 온도 값이 들어가게 되면서 customTable에 값을 저장할 때 마다 해당 값이 초기화가 된다. 이는 현재 로직으로는 따로 수정할 수 없는 사안이다.

  

현재 로직이 DB 설계에 오류가 있기 때문에 발생했다…

## 해결안

### DB구조 변경

custom table의 컬럼 구조

num , id, min, max

pk는 id가 되어야하고 num은 순서가 되어 저장되어야 한다. DB에서 값을 뽑아서 쓸때는 num을 기준으로 정렬해서 사용하면 된다.

  

변경되어야하는 DB

Food ,Machine, custom_food, custom_machine

해당 모두 pk를 id로 변경하고 num을 zenput 순서값으로 지정한다.

## JPA naming issue

현재 ID는 num으로 되어있다. 따라서 JPA 로직을 사용할때 DB id컬럼이 아닌 num컬럼을 사용해 버린다. 사실 위 문제는 customTable의 컬럼 구조를 변경하면 이상없는 사항이다.

  

# 3월 16일 추가

아니다 아니야!!

PK는 Num이 되어도 괜찮다. 어짜피 특별한 의미를 갖고 있지 않는 숫자고 @Id 는 꼭 PK에만 부여해야하는 사안이 아니다. 그래서 DB 컬럼명을 바꾸지 않아도 된다. 그냥 Custom Table을 저장하는 로직만 변경하면 된다.

객체를 뽑아서 update하는 방향으로